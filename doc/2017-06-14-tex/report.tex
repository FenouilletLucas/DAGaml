\documentclass[a4paper,10pt]{article}
%\usepackage{fullpage}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[english]{babel}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{mathabx}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{stmaryrd}
\usepackage{paralist}

\usepackage{cite}

\lstset{breaklines=true,
 basicstyle=\small,
 mathescape=true,
	%language=caml,
	numbers=left,
 numberstyle=\tiny \bf, %\color{blue},
 %stepnumber=2,
 numbersep=10pt,
 %firstnumber=11,
 numberfirstline=true
	}

\title{A Generalized Reduction of Ordered Binary Decision Diagram\\{\small Internship at DFKI (Bremen, Germany) from 15/03/2017 to 15/06/2017}}
\author{Joan Thibault\\Supervisor: Rolf Drechsler}

\newcommand{\includeframe}[4]{\makebox[#2\linewidth]{\includegraphics[page=#1,width=#2\linewidth,trim=0cm 0cm 0cm 0cm,clip=true,#3]{#4}}}


\newcommand{\shannon}[3]{{#1}\longrightarrow_S{#2}, {#3}}
\newcommand{\N}{\mathbb{N}}%{\{0, 1\}}
\newcommand{\B}{\mathbb{B}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\Y}{\mathbb{Y}}
\newcommand{\I}{\mathbb{I}}
\newcommand{\Ynode}{\Y\mathtt{-node}}
\newcommand{\Ynodes}{\Y\mathtt{-nodes}}
\newcommand{\T}{\mathbb{T}}
\newcommand{\Uextract}{"\texttt{U}seless variables extraction"}
\newcommand{\uextract}{"\texttt{U} extract"}
\newcommand{\NNIextract}{"input \texttt{N}egation and output \texttt{N}egation \texttt{I}nvariant extraction"}
\newcommand{\nniextract}{"\texttt{NNI} extract"}
\newcommand{\Xextract}{"1-prediction extraction"}
\newcommand{\xextract}{"\texttt{X} extract"}
\newcommand{\GroBdd}{\texttt{GROBDD}}
\newcommand{\GroBdds}{\texttt{GROBDDs}}
\newcommand{\fieldVar}{\texttt{var}}
\newcommand{\fieldIndex}{\texttt{index}}
\newcommand{\fieldNode}{\texttt{node}}
\newcommand{\fieldGamma}{\mathtt{\gamma}}
\newcommand{\fieldThen}{\mathtt{if1}}
\newcommand{\fieldElse}{\mathtt{if0}}
\newcommand{\bras}[1]{{\left\llbracket{#1}\right\rrbracket}}


%\newcommand\restr[2]{{% we make the whole thing an ordinary symbol
% \left.\kern-\nulldelimiterspace % automatically resize the bar with \right
% #1 % the function
% \vphantom{\big|} % pretend it's a little taller at normal size
% \right|_{#2} % this is the delimiter
% }}
\newcommand\restr[2]{{#1}_{\left|{#2}\right.}}

%\newtheoremstyle{plain}
\newtheorem{newtheo}{Theorem}
\newcommand{\theorem}[2]{\begin{newtheo}{\textsf{#1}\\} #2 \end{newtheo}}

%\theoremstyle{definition}
\newtheorem{newdef}{Definition}
\newcommand{\definition}[2]{\begin{newdef}{#1\\}#2\end{newdef}}

\newtheorem{newcons}{Constraint}
\newcommand{\constraint}[2]{\begin{newcons}{#1\\}#2\end{newcons}}

\begin{document}



\maketitle
\begin{abstract}
The Reduced Ordered Binary Decision Diagram (ROBDD)\cite{Bryant1986, Somenzi1999} is the state-of-the-art representation for Boolean functions and used in various fields such as logic synthesis, artificial intelligence or combinatorics.
However, efficient manipulation of ROBDDs is memory expensive.
Several variants exist which allows to capture some properties of Boolean functions in order to simplify their representation and reduce the computation time (e.g. "output negation").
Some variants are specialized in the representation of some subsets of Boolean functions, for example Zero Suppressed Binary Decision Diagrams (ZBDDs) which are more suitable for sparse functions.
Simply merging variants may break canonicity (for example ZBDD and "output negation").
Therefore, we designed GROBDD (Generalized Reduction of Ordered Binary Decision Diagram): a framework that aims at providing sufficient conditions in order to ensure the semi-canonicity of the representation.
Using GROBDD, we designed three new variants, namely: \Uextract{}, \NNIextract{} and \Xextract{}.
These variants have been implemented using OCaml \cite{DAGamlGitHub} and tested against several set of circuits \cite{BenchIscas99, BenchLgsynth91} and CNF formulas \cite{BenchSatlib}.
\end{abstract}

\newpage

\section{Introduction}

Nowadays, most critical systems rely on digital circuits: in transports (e.g. cars, train, plains), communication (e.g. satellites), computation (e.g. data centers, super-computers), exploration (e.g. space rocket, rovers).
One way to minimize risks in digital parts of these systems is to provide a formal proof that they respect their specification.
On the other hand, we want to minimize costs and energy consumption while maximizing their performances.
In order to efficiently optimize digital circuits we usually rely on complex programs.
However, these programs are rarely proven themselves, thus, circuits optimized using them might not be equivalent to the initial design and therefore might not respect the specification.
The obvious solution would be to prove optimizing programs, however two major issues arise: these programs are complex (thus, proving them would be expensive) and might be proprietary (thus, one cannot check that the proof is correct).
A simpler alternative is to design a program which checks that two digital circuits are equivalent.
With this alternative, the only piece of software that needs to be proven is the "equivalence checker".


In order to prove that two digital circuits are equivalent, there are two main algorithmic solutions: (1) the DPLL (Davis–Putnam–Logemann–Loveland) algorithm and (2) compilation to ROBDD (Reduced Ordered Binary Decision Diagram).
The DPLL algorithm is a procedure usually implemented with various heuristics such as \textit{unit propagation}, early conflict detection or \textit{conflict driven clause learning}.
Secondly, the compilation of both circuits into Reduced Ordered Binary Decision Diagrams (ROBDDs).
In this report we will focus on ROBDD: a canonical structure which represents a vector of functions as a multi-rooted hash-consed Directed Acyclic Graph (DAG).
Compiling a function into a ROBDD is an exponential time (in the number of variables) process in the worst case, however, testing two functions for equality is a constant time operation.


However, unlike the DPLL algorithm, efficiently compiling a function into a ROBDD is memory expensive.
Therefore, variants were invented in order to capture some semantic properties of the function, hence, reducing the size of the representation and the computation time.
For example, Zero suppressed Binary Decision Diagrams (ZBDDs) are better suited to represent sparse functions.
In this report we use the "output negation" variant\cite{BryantVariantN}, which extends the reduction rules in order to guarantee canonicity under negation, therefore, allowing to negate a function in constant time.
Other extensions of the reduction rules exist such as: "input negation"\cite{MinatoVariants} (each edge can complement the locally first input), "shifting variables"\cite{MinatoVariants} (each edge stores the number of useless variables before the next significant variables) or "dual edge"\cite{RolfVariantDual} (we define the dual of a function $f$ by $\bar{f} = (x_1, \dots, x_n) \longrightarrow \lnot f(\lnot x_1, \dots, \lnot x_n)$, therefore the reduction works similarly to the "output negation").

However, simply merging two variants may break the canonicity (e.g. ZBDD and "output negation").
Therefore, we designed the \GroBdd{} (Generalized Reduction of Ordered Binary Decision Diagram) framework as a way of (1) defining sufficient constraints on allowed transformation that ensures the structure to be canonical (2) finding new variants using a systematic approach.

In order to show the effectiveness of our approach, we introduce three new variants: \Uextract{} (or \uextract{} for short), the \NNIextract{} (or \nniextract{} for short) and \Xextract{} (or \xextract{} for short).


The remainder of this report will be organized as follows.
In Section~2, we formally introduce Boolean functions, useless variables and some notations.
Then, we introduce ROBDD in Section~3 and \GroBdd{} in Section~4.
In Section~5, we introduce the \uextract{} variant as part of the \GroBdd{} framework, before exposing results against three different benchmarks \cite{BenchSatlib, BenchLgsynth91, BenchIscas99} using our implementation in OCaml.

\section{Notations}

Reduced Ordered Binary Decision Diagrams represent Boolean functions.
In this section we introduce notations necessary to their manipulation.

Let $A$ be a set of elements and $a, b\in\N$ a pair of integers, we denote $X_{\bras{a, b}}\in A^{b-a+1}$ a vector of $(b-a+1)$ elements of $A$ and $A_k$ its $(k-a+1)$-th element (with $k\in\bras{a, b}$).

We denote the set of Booleans $\B = \{0, 1\}$.
The set of Boolean vectors of size $n\in\N$ is denoted $\B^n$.
The set of Boolean functions of arity (i.e. the number of variables) $n\in\N$ is denoted $\F_n = \B^n \longrightarrow \B$.


We denote the conjunction by $\land$ (AND), the disjunction by $\lor$ (OR), the negation by $\lnot$ (NOT) and the symmetric difference by $\oplus$ (XOR).
We denote the Shannon operator by $\shannon{}{}{}$ defined by $\forall x, y, z\in\B, \shannon{x}{y}{z} = (\lnot x \land y) \lor (x \land z)$).

\definition{Restriction}
{
	Let $f\in\F_{n+1}$ be a Boolean function of arity $n+1$ and $b\in\B$ be a Boolean.
	We denote $\restr{f}{b} = (x_1, \dots, x_n) \longrightarrow f(b, x_1, \dots, x_n)$.
	Remark: $\restr{f}{0}$ is called the negative restriction of $f$ and $\restr{f}{1}$ is called the positive restriction of $f$
}

\definition{Construction}
{
	Let $f, g\in\F_n$ be a pair of Boolean functions of arity $n$.
	We denote $f\star{}g$ the Boolean function of arity $n+1$ defined by $ f\star{}g = (x_0, x_1, \dots, x_n) = \shannon{x_0}{f(x_1, \dots, x_n)}{g(x_1, \dots, x_n)}$.
	N.B.: $\restr{(f\star g)}{0} = f$ and $ \restr{(f\star g)}{1} = g$.
}

\theorem{Expansion Theorem}{
Let $f\in\F_{n+1}$ be a Boolean function, then $f = \restr{f}{0} \star \restr{f}{1}$.
}

\definition{Useless Variables}
{
Let $f\in\F_{n+1}$ be a Boolean function and $i\in\bras{0, n}$ be an integer.
We say that the $i$-th variable of $f$ is useless, iff $\forall (x_1, \dots, x_n)\in\B^n, f(x_1, \dots, x_{i-1}, 0, x_i, \dots, x_n) = f(x_1, \dots, x_{i-1}, 1, x_i, \dots, x_n)$
}

\definition{1-Prediction}
{
Let $f$ be a Boolean function of arity $n+1$, $i\in\bras{0, n}$ be an integer, $t$ and $r$ be Booleans.
We say that the function $f$ admits a 1-prediction $(i, t, r)$ iff $\forall (x_1, \dots, x_n), f(x_1, \dots, x_{i-1}, t, x_i, \dots, x_n) = r$.
}

\definition{Polarity-Phase Invariant}
{
Let $f$ be a Boolean function of arity $n$, and $X=(y, z_1, \dots, z_n)\in\B^{n+1}$ be a vector of $n+1$ Booleans.
We say that $X$ is a polarity-phase invariant of $f$, iff $\forall (x_1, \dots, x_n)\in\B^n, f(x_1, \dots, x_n) = y\oplus{}f(x_1\oplus{}z_1, \dots, x_n\oplus{}z_n)$.
Similarly to Burch and Long \cite{BurchLong1992}, we can prove that the set of polarity-phase invariant of a function is a linear space.
Such a linear space can be represented as a row-echelon matrix of Booleans.
}

\section{Reduced Ordered Binary Decision Diagram (ROBDD) and Canonicity}

\paragraph{Definition of Binary Decision Diagram (BDD)\\}

A Binary Decision Diagram is a directed acyclic graph $(V\cup T, \Psi \cup E)$ representing a vector of Boolean functions $F_\bras{1, k}$ over an infinite set of variables (but with a finite support set).
Nodes are partitioned into two sets: the set of internal nodes $V$ and the set of terminal nodes $T$.
Every internal node $v\in V$ has one field $\fieldVar{}$, which represents the index of a variable and two outgoing edges respectively denoted $\fieldElse{}$ and $\fieldThen{}$.
When using the "output negation" variant, there is only one terminal called 0, which represents the constant function returning 0.
Edges are partitioned into two sets: the set of root edges $\Psi$ and the set of internal edges $E$.
There is exactly $k$ root edges, a root edge is denoted $\Psi_i$ (with $i\in\bras{1, k}$, informally, $\Psi_i$ is the root of the ROBDD representing $f_i$.
Every edge has an inversion field $neg\in\B$ and a destination node denoted $\fieldNode{}$.

%add beautiful draw (with \psi edges)$

We denote $\phi(node)$ the semantics of the node $node$ and $\psi(edge)$ the semantic of the edge $edge$ as follow: \begin{itemize}
\item $\forall i, F_i = \psi(\Psi_i)$
\item $\forall edge \in \Psi \cup E, \psi(edge) = edge.neg \oplus \phi(edge.\fieldNode{})$
\item $\phi(0 \in T) = 0$
\item $\forall node \in V, \phi(node) = \shannon{node.\fieldVar{}}{\psi(node.\fieldElse{})}{\psi(node.\fieldThen{})}$
\end{itemize}

\definition{Reduced Ordered Binary Decision Diagram (ROBDD)}
{
A BDD is said \texttt{Ordered} if (1) $\forall v\in V$, $v.\fieldThen{}.\fieldNode{}\in V \Rightarrow v.\fieldVar{}> v.\fieldThen{}.\fieldNode{}.\fieldVar{}$ and $v.\fieldElse{}.\fieldNode{}\in V \Rightarrow v.\fieldVar{}> v.\fieldElse{}.\fieldNode{}.\fieldVar{}$ (i.e. the $\fieldVar{}$ field of any node is greater than the $\fieldVar{}$ field of its children).
%define an order over variables
A BDD is said \texttt{Reduced} if (2) $\forall v\in V, v.\fieldElse{} \neq v.\fieldThen{}$ and (3) every node has an in-degree strictly positive.\\
A \texttt{Reduced} and \texttt{Ordered} BDD is called a ROBDD.
}

\theorem{ROBDDs are canonical}
{
Let us consider a ROBDD $G$ representing the vector of Boolean functions $F=(f_1, ..., f_n)$, then for every nodes $v_1, v_2 \in G$, $\phi(v_1) = \phi(v_2) \Leftrightarrow v_1 = v_2$.
}
A proof of this theorem is available in the review of Somenzi et al.\cite{Somenzi1999}.

\paragraph{Effective construction\\}
In practice, ROBDDs are created starting from the ROBDDs for constants and variables and by applying operators (e.g. NOT, AND, XOR, quantification operators, restriction, etc.) and are kept reduced at all times.
A ROBDD is a multi-rooted diagram which represent a vector of Boolean functions, the equality test between two of this function is a constant time operation.
Canonicity is ensured by using an association table (usually a hash table), which maps all nodes to an identifier (usually a pointer to the node itself).
Therefore, before creating a new node, all procedure must first check that it does not already exists. If it does, the procedure retrieves its identifier, otherwise, generates a new identifier and adds the pair node-identifier into the association table.
The association table is usually called \textit{unique table}.

\paragraph{Zero Suppressed Binary Decision Diagram (ZBDD)}
The main difference between ROBDD and ZBDD stands in how they chose to remove nodes.
In a ROBDD, nodes $node$ with $node.\fieldElse{}$ identical to $node.\fieldThen{}$ are removed.
In a ZBDD, nodes $node$ with $node.\fieldElse{}$ pointing to the terminal node $0$ are removed.
Additionally, as ZBDD and "output negation" are not compatible, there are two terminal nodes respectively denoted $0$ and $1$).

\section{Introduction of Generalized Reduction of Ordered Binary Decision Diagram (\GroBdd{})}

Creating new canonical variants is a painful task for several reasons, such as: (1) the combination of two canonical variants is not necessarily one, (2) proving that a variant is canonical from scratch needs to turn a local property into a global one and (3) we have no idea on what a variant should look like.

We designed the Generalized Reduction of Ordered Binary Decision Diagram (\GroBdd{}) framework, in order to properly define what a model is.
This definition would help us defining sufficient conditions on the variant which ensure the structure to be canonical (or semi-canonical).
In this section, we formally define \GroBdd{}s, then deduce a set of sufficient properties which ensure the canonicity (or the semi-canonicity) of a \GroBdd{}.

The \uextract{} variant ensures that the function represented by any node does not have useless variable.
Therefore, it sets an upper bound on the number of nodes of arity $n$ to $2^{2^n}$.
Furthermore, it allows to "copy" functions at (almost) no cost as the expression $f(x_1, x_3, x_5, x_7)$ and $f(x_0, x_1, x_3, x_5)$ share the same structure.
This variant is a generalization of the "shifting variables"\cite{MinatoVariants} variant.


The \nniextract{} variant allows output \underline{and inputs} negation, therefore making the structure invariant under input and output negation (which ensures that there is at most $2^{2^n-n}$ nodes of arity $n$).
However, keeping the structure canonical, requires to compute the set of polarity-phase invariants of a manipulated function (defined in Section~1).
This was done by generalizing the work of Burch and Long\cite{BurchLong1992} from phase-invariants (only inputs) to polarity-phase invariants (output and inputs).
Thankfully, we can "extract" polarity-phase invariants into edges saving one variable per dimension of the linear space.
This variant is a generalization of the following variants: "output negation"\cite{BryantVariantN}, "input negation"\cite{MinatoVariants} and "dual edge"\cite{RolfVariantDual}.

The \xextract{} variant allows to "extract" 1-predictions (defined in Section~1).
This variant is a generalization of ZBDD\footnote{ZBDD is special case of \xextract{}, with the only extractable 1-prediction being $(0, 0, 0)$} and is compatible with "output negation" and \uextract{} but not with \nniextract{}.

Due to the limited length of this report, we will only detail the \uextract{} variant (cf. Section~5) and will not detail further the \nniextract{} and \xextract{} variants.



\subsection{Definition of \GroBdd{}}

\subsubsection{structure}

A \GroBdd{} is a directed acyclic graph $(V\cup T, \Psi \cup E)$ representing a vector of Boolean functions $F_\bras{1, k}$ is defined similarly to a ROBDD.
Nodes are partitioned into two sets: the set of internal nodes $V$ and the set of terminal nodes $T$.
Every internal node $v\in V$ has a field $\fieldIndex{}$ which represents a unique identifier associated to each node and two outgoing edges respectively denoted $\fieldElse{}$ and $\fieldThen{}$.
Edges are partitioned into two sets: the set of root edges $\Psi$ and the set of internal edges $E$.
There is exactly $k$ root edges, a root edge is denoted $\Psi_i$ with $0\leq i < k$, informally, $\Psi_i$ is the root of the \GroBdd{} representing $f_i$.
Every edge has a transformation descriptor field $\gamma$ and a destination node denoted $\fieldNode{}$.

\subsubsection{semantic interpretation}
We denote $\rho(\gamma): \F_n \longrightarrow \F_m$ the semantic interpretation of the transformation descriptor $\gamma$.
We define $\phi(node)$ the semantic of the node $node$ and $\psi(edge)$ the semantic of the edge $edge$ as follow: \begin{compactitem}
\item $\forall i, F_i = \psi(\Psi_i)$
\item $\forall edge \in \Psi \cup E, \psi(edge) = \rho(edge.\fieldGamma{})(\phi(edge.\fieldNode{}))$
\item $\forall node \in V, \phi(node) = \psi(node.\fieldElse{}) \star \psi(node.\fieldThen{})$
\end{compactitem}
We assume the function $\phi$ defined on all terminals $T$ (we always assume, all terminals to have a different interpretation through $\phi$).
We define the set of transformations $\T = \{\rho(\gamma)~|~\gamma\in\Y\}$ as the set of semantic interpretation of transformation descriptors (and $\forall n, m\in\N, \T_{n, m} = \T \cap (\F_n \longrightarrow \F_m)$)..

\subsubsection{definition: A \GroBdd{} model}
{
A \GroBdd{} model is a 7-uplet $(T, \Y, \rho, \texttt{C}, \I, \texttt{B}, \mathcal{P})$:
\begin{compactenum}
\item $T$: The set of all terminal nodes
\item $\Y$: The set of all transformation descriptors
\item $\rho$: The semantic interpretation of a transformation descriptor
\item $\texttt{C}: \Y \longrightarrow \Y \longrightarrow \Y$: The \texttt{C}omposition operator, ensuring that $\rho(\texttt{C}(\gamma, \gamma')) = \rho(\gamma')\circ\rho(\gamma)$ (\texttt{C} can be a partial function).
\item $\I$: The set of identifiers.
\item $\mathtt{B}: (\Y\times\I)\times(\Y\times\I) \longrightarrow$\\
 $|~\texttt{ConsNode}$ $\Y\times (\Y\times\I) \times (\Y\times\I)$\\
 $|~\texttt{Merge}$ $\Y\times\I$\\
The \texttt{B}uilding operator, ensuring that:\begin{compactenum}
\item $\texttt{B}((\gamma, I_g), (\gamma, I_h))= \texttt{ConsNode} (\gamma, (\gamma'_X, I_X), (\gamma'_Y, I_Y))$\\$\Rightarrow f = \rho(\gamma)\left(\rho(\gamma'_X)(X) \star \rho(\gamma'_Y)(Y))\right)$
\item $\texttt{B}((\gamma, I_g), (\gamma, I_h))= \texttt{Merge} (\gamma'_Z, I_Z) \Rightarrow f = \rho(\gamma'_Z)(Z)$
\end{compactenum}
(with $f = \rho(\gamma_g)(g) \star \rho(\gamma_h)(h)$), (\texttt{B} can be a partial function)
\item $\mathcal{P}: V\longrightarrow\B$: The "local semantic reduction" predicate.
\end{compactenum}
}

\paragraph{The \texttt{cons} procedure} is defined by:
\begin{lstlisting}
let $\texttt{cons}$ grobdd arc0 arc1 = match $\texttt{B}((arc0.\fieldGamma{}, arc0.\fieldNode{}.\fieldIndex{}), (arc1.\fieldGamma{}, arc1.\fieldNode{}.\fieldIndex{}))$ with
  | $\texttt{ConsNode}$ $(\gamma, (\gamma', I'), (\gamma'', I'')) \longrightarrow$
    let $N$ = $\{\fieldElse{} = \{\fieldGamma{} = \gamma', \fieldNode{} = I'\}, \fieldThen{} = \{\fieldGamma = \gamma'', \fieldNode{} = I''\}\}$ in
    let $I$ = if ($N$ exists in the unique table of grobdd)
      then ($N$'s identifier)
      else
      (generate a new identifier $I$ for $N$ and create the association ($I$, $N$) into grobdd's unique table) in
    {$\fieldGamma{}$ = $\gamma$, $\fieldNode$ = $I$}
  | $\texttt{Merge}$    $(\gamma, I) \longrightarrow$ {$\fieldGamma{}$ = $\gamma$, $\fieldNode$ = $I$}
\end{lstlisting}

Properties 6.a and 6.b on the \texttt{B}uilding operator are necessary and sufficient to ensure that
\begin{lstlisting}
$\psi$($\texttt{cons}$ grobdd arc0 arc1) = ($\psi$ arc0) $\star$ ($\psi$ arc1)
\end{lstlisting}

\subsubsection{Reduction rules}

We define three reduction rules: \begin{compactenum}
\item All sub-graphs are different up to graph-isomorphism (i.e. all identical sub-graphs are merged)
\item All internal nodes satisfy the "local semantic reduction" predicate.
\item All nodes have at least one incoming edge.
\end{compactenum}
A \GroBdd{} is said reduced iff it satisfies the reduction rules.

\subsection{Constraints}
We make a list of sufficient conditions on models which ensure the (semi-)canonicity of the structure.
Most of them are conjectured to be necessary.
\subsubsection{Transformation Set}

The set of transformation descriptors must be uniquely mapped to the set of transformations\footnote{assuming otherwise, it exists a pair of distinct transformation descriptors that have the same semantic interpretation, therefore, we can create two structures which are distinct but equivalent}: $\forall t\in T, \exists!\gamma\in\Y, t=\rho(\gamma)$.
Transformations produce bigger functions than their input\footnote{assuming otherwise, let $t\in\T_{n, m}$ (with $n>m$) be such a transformation, $t$ is not injective($\#\F_n > \#\F_m$), it exists a pair of distinct functions which have the same image $f$ through $t$, therefore $f$ may have several representations}: $\forall n > m \in\N, \T_{n, m}=\emptyset$.
Transformations are composable: $\forall n \leq m \leq l\in\N, \forall t\in\T_{n, m}, \forall t'\in\T_{m, l}, t' \circ t \in\T_{n, l}$.
Hence, for all integer $n\in\N$, $\T_{n, n}$ is stable by composition.
For all integer $n\in\N$, we define $A_n = \T_{n, n}$ the set of asymmetric transformations, such transformations are one-on-one mapping of Boolean functions $\F_n$ of arity $n$.
Thus, for all pair $n, m\in\N$ of integers, we define the set of symmetric transformations $S_{n, m} \subset \T_{n, m}$, such that (1) $\forall t\in\T_{n, m}, \exists!(s, a)\in(S_{n, m}\times A_n), t = s \circ a$\footnote{remark: splitting transformations into their symmetric and asymmetric components was our "Eureka!" to solve the problem of properly defining semi-canonicty, i.e. a form of canonicity which allow nodes to be A-equivalent instead of strictly identical between to distinct representations.} and (2) $\forall n\in\N, S_{n, n} = \{Id_n\}$.
Let $f\in\F_m (m\in\N)$ be a Boolean function, we say that $f$ is S-free iff $\forall n < m, \not\exists (t, f')\in(\T_{n, m}\times\F_n), t(f') = f$. We denote $\F^S$ the set of S-free functions and for all integer $n\in\N$, $\F^S_n  = \F^S\cap\F_n$ the set of S-free functions of arity $n$.
For all function $f\in\F_m (m\in\N)$, $\exists!(t, f')\in(\T\times\F^S), t(f') = f$ (conjectured necessary), we respectively denote $\bar{f}$ such a $f'$ and $t_{\bar{f}\rightarrow f}$ such a $t$ (if $f$ is S-free, $\bar{f}=f$ and $t_{\bar{f}\rightarrow f} = Id$).
We say that two Boolean functions $f, f'\in\F_n (n\in\N)$ are A-equivalent iff $\exists t\in A_n, f=t(f')$, we denote $\sim_A$ this equivalence relation (it two functions are not A-equivalent, they are A-distinct).
We say that a Boolean function $f\in\F_n (n\in\N)$ is A-invariant free iff $\forall a\in A_n, f\neq a(f)$, we denote $\F^A\subset\F$ the set of A-invariant free function and $\F^A_n = \F^A\cap\F_n$ the set of A-invariant free function of arity $n$.
We set the constraint that all S-free function are A-invariant free: $\F^S\subset\F^A$.



\subsubsection{Terminals}
Terminal nodes are interpreted as Boolean function of arity 0, thus, S-free.
Terminal nodes are correct iff (1) $A_0=\{Id\}$, $T=\{0, 1\}$, $\phi(0) = () \rightarrow 0$ and $\phi(1) = () \rightarrow 1$ OR (2) $A_0\neq\{Id\}$, $T=\{0\}$ and $\phi(0) = () \rightarrow 0$.
Terminals are S-free ($\forall t\in T, \phi(t)\in\F^S_0$) and A-distinct ($\forall t\neq t'\in T, \phi(t) \not\sim_A \phi(t')$).
We assume defined the function $E_0: \F_0 \longrightarrow E$, such that $\forall b\in\F_0, \psi(E_0(b)) = b$. 


\subsubsection{Building operator \texttt{B}}

Let $X$ be a function, we denote $I_X$ the identifier of an hypothetical node whose semantic interpretation is $X$.
For all $n\in\N$, we denote $\I_n$ the set of identifiers corresponding to node representing functions of arity $n$.

\definition{a node is \texttt{B}-stable}
{
Let $G$ be a \GroBdd{}, we denote $v$ an internal node of $G$.
We denote $t_0 = v.\fieldElse{}.\fieldGamma{}, I_0 = v.\fieldElse{}.\fieldNode{}, t_1 = v.\fieldThen{}.\fieldGamma{}$ and $I_1 = v.\fieldThen{}.\fieldNode{}$.
The node $v$ is said B-stable iff $\mathtt{B}(t_0, I_0, t_1, I_1) = \mathtt{ConsNode}(Id, (t_0, I_0), (t_1, I_1))$.
We define the "local semantic reduction" predicate $\mathcal{P}$, by for all node $v\in V$, $\mathcal{P} v$ is true iff $v$ is B-stable.
}

The exhaustive list of sufficient constraints are listed in Annexes~\ref{grobdd-B-constraints} (namely: \texttt{B} is \texttt{B}-stable, \texttt{B} is S-free preserving and \texttt{B} is A-distinct preserving).


\subsection{\GroBdd{} are (Semi-)Canonical}
We refer the reader to Annexes (Section~\ref{grobdd-reduction}) for a proof that under previous constraints, a \GroBdd{} has the following properties: \begin{compactenum}
\item For all vector of Boolean function $F$ there exists a reduced \GroBdd{} $G$ representing it.
\item A reduced \GroBdd{} $G$ is semi-canonical, defined as: \begin{compactenum}
\item For all node $v\in V$, $\phi(v)$ is S-free.
\item For all pair of nodes $v, v'\in V$, $\phi(v)$ and $\phi(v')$ are A-distinct.
\item If two edges $a$ and $a'$ represent the same function, then $a.\fieldGamma{} = a'.\fieldGamma{} \land a.\fieldNode{} = a'.\fieldNode{}$.
\end{compactenum}
\item Between two reduced \GroBdd{} $G$ and $G'$ representing the same vector of Boolean functions $F$, there exists a one-to-one mapping $\sigma: V \longrightarrow V'$ such that $\forall v, v' \in V \times V', \sigma(v) = v' \Rightarrow (\exists a \in A_{*}, \phi(v) = \rho(a)(\phi(v'))$.
\end{compactenum}
Furthermore, we can prove that, if the set of unique identifiers has no order $\I$ (i.e. the operator < is not defined on $\I$) then the structure is canonical.

\subsection{Conclusion}

In this section, we introduced the concept of Generalized Reduction of Ordered Binary Decision Diagrams (\GroBdd{}) and provided a set of conditions and reduction rules, which are sufficient to guarantee the reduced structure to be semi-canonical.
This approach still allows to perform the equality test in a reasonable amount of time: proportional to the size of the transformation descriptor, which (for practical reasons) should be polynomial in the arity of the post-transformation function.
In the remaining of this report, a \GroBdd{} is to be assumed reduced.
We implemented five variants respectively denoted \texttt{N} (equivalent to ROBDD with "output negation"), \texttt{Z} (equivalent to ZBDD), \texttt{NU} ("output negation" and \uextract{}), \texttt{NNI} (\nniextract), \texttt{NU-X} (\texttt{NU} and \xextract{}).
In the next section, we (1) introduce the variant \texttt{NU} and (2) compare the variants \texttt{Z}, \texttt{NU}, \texttt{NNI} and \texttt{NU-X} against \texttt{N}.


\section{Useless Variable Extraction: \GroBdd{} model NU}

\subsection{Motivation}

There are several interests in extracting useless variables, the more obvious one is that it tends to reduce the number of nodes (relatively to a regular ROBDD representing the same function with the same order).
Here is a list of other interesting properties: \begin{compactitem}
\item When formalizing a problem it may appear that there exists a sub-problem that is present several times but on different variables with the same relative order, for example: in the n-queens problem: "there is exactly one queen per line" is a constraint that either you replicate or solve once and replicate the result.
With the \uextract{} variant, we can solve the problem once and then, by creating the appropriate edge, replicating the solution without creating new nodes.
\item Given a function, we can know which variables are useless, just by looking at the transformation descriptor, thus without going through the whole structure.
\end{compactitem}

\subsection{Definition}

\paragraph{Definition of the Transformation Descriptor Set (TDS)}

We define the Transformation Descriptor Set (TDS) of the variant \texttt{NU} : "output Negation" + \uextract{} by: $\Y_{n, m} = \{\{neg = b, sub = s\}~|~ b\in\B, s\in\B^m, \sum_i s_i = n\}$

For all transformation descriptor $\gamma\in\Y_{n, m}$, we denote $\rho(\gamma) \in \F_n \rightarrow \F_m$ its semantic interpretation.
Informally, let $\gamma\in\Y_{n, m}$ be a transformation descriptor and $f\in\F_n$ be a function without useless variables, then the $k$-variable of the Boolean function $\rho(\gamma)(f)$ is useless iff $\gamma.sub_k$ is false.

Additionally, we define the set of terminals $T=\{0\}$, we define $\phi(0)=()\longrightarrow{}0\in\F_0$ , we define $\forall b\in\B, E_0(()\longrightarrow b\in\F_0) = \{\gamma = \{neg = b, sub = ()\}, node = I_0\}$.

\paragraph{Definition of the semantic interpretation}

For all transformation descriptor $\gamma\in\Y_{n, m}$, we denote $S_\gamma = \left(i_1 < i_2 < \dots < i_n\right)$ the exhaustive list of indexes $i$ for which $\gamma.sub_i$ is true.
Therefore, for all function $f\in\F_n$ we define $\rho(\gamma)(f) = (x_1, \dots, x_m) \longrightarrow \gamma.neg \oplus f(x_{i_1}, x_{i_2}, \dots, x_{i_n})$.
For convenience reasons, we allow ourselves to define the $\gamma.sub$ component using the $S_\gamma$ notation instead of the Boolean vector one.


 
\paragraph{The \GroBdd{} model NU is semi-canonical}
We can prove (cf. Annexes, Section~\ref{grobdd-model-nu}) that the model \texttt{NU} satisfies all constraints formulated in Section~4 (Introduction of \GroBdd{}).
Therefore, we proved that a \GroBdd{} which uses the model \texttt{NU} is semi-canonical.
Actually, as the building algorithm \texttt{B} only uses the equality test between node's identifier, we can prove that the structure is canonical (up to graph isomorphism).
In the next section, we compare representations generated by this new variant and regular ROBDD (with just the "output negation" variant) on three different benchmarks in terms of number of nodes and estimated memory cost.

\subsection{Results}
In this section, we start by quickly presenting our implementation of previous concepts, then, average results of our approach on three different benchmarks (involving circuits and CNF formulas), finally, we expose the impact on using different \GroBdd{} models to represent solutions of the N-Queens problem.

\subsubsection{Implementation details}
Our implementation in OCaml of the previous concepts is available on GitHub as part of the DAGaml framework within the \texttt{grobdd} branch \cite{DAGamlGitHub}.
The core program, i.e. the \GroBdd{} abstraction, is about 1~900 lines of code.
Implementation of variant specific details about 6~100 lines of code: \texttt{N} (318 lines), \texttt{Z} (201 lines), \texttt{NU} (728 lines), \texttt{NNI} (1~939 lines) and \texttt{NU-X} (2~587 lines).
Various useful tools are implemented (about 4~300 lines).
All in all, this project is about 12~400 lines long.
%The implementation is made of several layers of abstraction allowing to minimize variant specific sections.
%Additionally, a significant part of the source code and computation time is dedicated to self-checking the consistency of the operation.
%During this project, we focused our efforts into finding, implementing and validating new generalizations which would reduce the number of nodes.
We did not spent much time on minimizing the memory cost of our implementation, therefore, the estimated memory cost introduced in the next section should be considered carefully (at most) as an indicator.
One reason, is that the size of nodes in a ROBDD is constant (e.g. 22 bytes in Minoto et al. implementation \cite{MinatoVariants}), however, the size of nodes in a \GroBdd{} is variable (e.g. with the variant \texttt{NU}, a node which semantic interpretation is of arity $n$, costs about $(1+2n)$ bits).
Having nodes of variable size should complexify the memory management of a memory aware implementation of \GroBdd{}s.

\subsubsection{Results}



\begin{table}
\center
\small
\begin{tabular}{c | c | c | c | c | c | c | c | c}
& \multicolumn{2}{c|}{\texttt{lgsynth91}} & \multicolumn{2}{c|}{\texttt{iscas99}} & \multicolumn{2}{c|}{\texttt{uf20-91}} & \multicolumn{2}{c}{\texttt{uf50-218}} \\
variants      & \texttt{nodes} & \textbf{mem.} & \texttt{nodes} & \textbf{mem.} & \texttt{nodes} & \textbf{mem.} & \texttt{nodes} & \textbf{mem.} \\
\texttt{Z}    & +233\% & +233\%        & +162\% & +162\%        & -41\%  & -41\%         & -42\%  & -42\%        \\
\texttt{NU}   & -26\%  & -39\%         & -25\%  & -20\%         & -3\%   & +7\%          & -3\%  & +22\%        \\
\texttt{NNI}  & -60\%  & -63\%         & -56\%  & -49\%         & -30\%  & -10\%         & -39\%  & +5\%        \\
\texttt{NU-X} & -64\%  & -67\%         & -55\%  & -46\%         & -96\%  & -95\%         & -97\%  & -96\%        \\
\end{tabular}
\caption{Average improvement in term of number of nodes and estimated memory cost.
In columns "\texttt{nodes}" we have the relative number of nodes and in columns "\textbf{mem.}" the relative estimated memory cost.
}
\label{results}
\end{table}

We compare the number of nodes and the estimated memory cost of variants \texttt{Z}, \texttt{NU}, \texttt{NNI} and \texttt{NU-X} relatively to \texttt{N}.
This results were obtained on four different benchmarks: \texttt{lgsynth91}\cite{BenchLgsynth91}, \texttt{iscas99}\cite{BenchIscas99}, \texttt{uf20-91}\cite{BenchSatlib} and \texttt{uf50-218}\cite{BenchSatlib}.
Benchmarks \texttt{lgsynth91} and \texttt{iscas99}, which represent various circuits, were pre-processed using the framework of logic synthesis ABC\cite{Abc}, in order to turn an arbitrary circuit into a simpler to parse And-Inverter-Graph (AIG).
The benchmark \texttt{uf20-91} (respectively \texttt{uf50-218}) represents a set of 1~000 satisfiable CNF formulas with 20 (respectively 50) variables and 91 (respectively 218) clauses.
Results are given relatively to the model \texttt{N}.


\subsubsection{The N-Queens problem}



\begin{table}[h]
\center
\begin{tabular}{|c | c | c | c | c |}
\multicolumn{5}{|c|}{quadratic version} \\
& & \multicolumn{3}{|c|}{\#node} \\
$N$ & \#\texttt{SAT} & \texttt{NU} & \texttt{NNI} & \texttt{NU-X} \\ \hline
1   & 1              & 1           & 0            & 0             \\
2   & 0              & 0           & 0            & 0             \\
3   & 0              & 0           & 0            & 0             \\
4   & 2              & 29          & 14           & 1             \\
5   & 10             & 166         & 26           & 6             \\
6   & 4              & 129         & 36           & 3             \\
7   & 40             & 1098        & 106          & 30            \\
8   & 92             & 2450        & 262          & 70            \\
\end{tabular}
\begin{tabular}{|c | c | c | c | c |}
\multicolumn{5}{|c|}{pseudo-linear version} \\
& & \multicolumn{3}{|c|}{\#node} \\
$N$ & \#\texttt{SAT} & \texttt{NU} & \texttt{NNI} & \texttt{NU-X} \\ \hline
1   & 1              & 1           & 0            & 0       \\
2   & 0              & 0           & 0            & 0       \\
3   & 0              & 0           & 0            & 0       \\
4   & 2              & 14          & 6            & 1       \\
5   & 10             & 73          & 15           & 6       \\
6   & 4              & 61          & 16           & 3       \\
7   & 40             & 348         & 39           & 30      \\
8   & 92             & 645         & 77           & 65      \\
\end{tabular}
\caption{Comparing models \texttt{NU}, \texttt{NNI} and \texttt{NU-X} on the representation of the solutions of the N-Queens problems using a quadratic encoding (one variable per cell) or a pseudo-linear encoding (one integer of logarithmic size per queen).}
\label{table-nqueens}
\end{table}

\begin{figure}
\center
\includeframe{1}{0.9}{}{nqueens.pdf}
\caption{Solution of the 5-queens problem, using variants: \texttt{NU}, \texttt{NNI} and \texttt{NU-X}.}
\label{figure-nqueens}
\end{figure}

The N-Queens problem, is the problem of positioning $N$ queens on an $N\times N$ chessboard, such that no queen threaten an other.
This problem can easily be reformulated as a Boolean function (either using an AIG or a CNF formula) by representing each cell as Boolean representing the statement: "there is a queen in this cell" and then be compiled into a \GroBdd{}.
We call this representation the "quadratic version" with each cell is represented (starting in the top left corner of chessboard, and then, line by line, down to the bottom right corner)
A slightly more complex formulation, use the fact that there is exactly one queen per colon of the chessboard, thus, we can use an integer ($\log n$ Booleans) to represent its position in the colon.
We call this representation the "pseudo-linear version", with integer being represented as interleaved Boolean vectors starting from the most significant bits.
Numbers of nodes for both version on each model are summarized in Table~\ref{table-nqueens}, we display a representation of the solutions of the 5-queens problem in Figure~\ref{figure-nqueens}.



\section{Conclusion}

ROBDD allows to efficiently manipulate functions appearing in various fields of computer science such as: Bounded Model Checking, Planning, Software Verification, Automatic Test Pattern Generation, Combinational Equivalence Checking or Combinatorial Interaction Testing.

However, ROBDD manipulation is memory intensive and several variants exist (such as "output negation") in order to reduce the memory cost.

In this report, we introduced a new class of variant called \GroBdd{} (Generalized Reduction of Ordered Binary Decision Diagram).
We presented a set of constraints which ensure a \GroBdd{} to be semi-canonical (i.e. canonical up to graph-isomorphism and A-equivalence, introduced in Section~4).
We introduced three new variants: \Uextract{} (or \uextract{} for short), the \NNIextract{} (or \nniextract{} for short) and \Xextract{} (or \xextract{} for short).
We defined five \GroBdd{} models denoted: \texttt{N} (equivalent to ROBDD with "output negation"), \texttt{Z} (equivalent to ZBDD), \texttt{NU} ("output negation" and \uextract{}), \texttt{NNI} (\nniextract{}), \texttt{NU-X} (\texttt{NU} and \xextract{}) and implemented them in DAGaml\cite{DAGamlGitHub} an OCaml software.

Experimentation shows (Table~\ref{results}) significant reduction of the number of nodes for both circuits \cite{BenchSatlib, BenchLgsynth91} and CNF formulas \cite{BenchIscas99} when using our variants.

Future work will be focused on merging the \nniextract{} variant and \xextract{} variant into the "\texttt{NNI-X} extract" variant.
Moreover, we will prove the correctness of \nniextract{} and \xextract{} variants, improve the binary representation of current transformation descriptors, implement quantification operators, implement heuristics to improve the compilation of CNF formulas.


\newpage
\bibliography{biblio}{}
\bibliographystyle{plain}

\newpage
\tableofcontents

\newpage

\section{Annexes}

\subsection{\GroBdd{}: Buildable (definition of \texttt{B})\label{grobdd-B-constraints}}
Here are the remaining constraints on the building operator \texttt{B}.
Let $X$ be a function, we denote $I_X$ the identifier of an hypothetical node whose semantic interpretation is $X$.

\constraint{\texttt{B} is \texttt{B}-stable}
{\[\forall \gamma_f, I_f, \gamma_g, I_g, \mathtt{B}(\gamma_f, I_f, \gamma_g, I_g) = \mathtt{ConsNode}(\gamma, (\gamma_0, I_0), (\gamma_1, I_1))\]
\[\Rightarrow \mathtt{B}(\gamma_0, I_0, \gamma_1, I_1) = \mathtt{ConsNode}(Id, (\gamma_0, I_0), (\gamma_1, I_1))\]
Informally, when B returns a node, this node is \texttt{B}-stable.
}

\definition{$\Ynode$}
{A $\Ynode_{l, m, n}$ is a quadruple $(\gamma_0, I_0, \gamma_1, I_1) \in \Y_{l, n} \times \I_l \times \Y_{m, n} \times \I_m$.
Let $v$ be a $\Ynode$, we denote $v.\gamma_0$ (respectively $v.I_0$, $v.\gamma_1$ and $v.I_1$) the first (respectively second, third and fourth) components of $v$.
\begin{compactenum}
\item For all $\Ynode$ $v$, we always assume that functions $\phi(v.I_0)$ and $\phi(v.I_1)$ are \texttt{S}-free.
\item All pair $f, f'$ of functions in $\{\phi(v.I_0) ~|~ v \in\Ynode\} \cup \{\phi(v.I_1) ~|~ v\in\Ynode\}$ are A-distinct.
\item  $\Ynodes$ $v$ are \texttt{B}-stable
\[\mathtt{B}(v.\fieldGamma{}_0, v.I_0, v.\fieldGamma{}_1, v.I_1) = \mathtt{ConsNode}(Id, (v.\fieldGamma{}_0, v.I_0), (v.\fieldGamma{}_1, v.I_1))\]
\end{compactenum}
We extend the definition of $\phi$, with : for all $\Ynode$ $v$, $\phi(v) = \rho(v.\gamma_0)(\phi(v.I_0)) \star \rho(v.\gamma_1)(\phi(v.I_1))$.
}
\constraint{\texttt{B} is S-free preserving}
{The algorithm \texttt{B} is said S-free preserving iff for all $\Ynode$ $v$, $\phi(v)$ is S-free.}

\constraint{\texttt{B} is A-reduction preserving}
{The algorithm \texttt{B} is said A-reduction preserving iff
\[\forall v, w \in\Ynode, \phi(v) \sim_A \phi(w) \Rightarrow v = w\]}

\subsection{\GroBdd{}: Reduction Rules and Semi-Canonicity Theorem\label{grobdd-reduction}}

\subsubsection{Existence}
We inductively define the procedure \texttt{E} with: \begin{compactitem}
\item $\forall b\in\F_0, \texttt{E}(b) = \texttt{E}_0(b)$
\item
Let $f$ be a Boolean function of arity $n$ (with $n \geq 1$).
Let $G$ be a \GroBdd{} representing functions $\restr{f}{0}$ (the negative restriction of $f$ according to its first variable) and $\restr{f}{1}$ (the positive restriction of $f$ according to its first variable.) by using the procedure \texttt{E} on $\restr{f}{0}$ and $\restr{f}{1}$.
Let $G'$ be the output of the \texttt{Cons} procedure on $G$, in order to create $f = \restr{f}{0} \star \restr{f}{1}$ (expansion theorem).\\
$E(f) = G'$
The \GroBdd{} $G'$ satisfies the reduction rules: \begin{compactitem}
\item If no node is created, the proof is straightforward.
\item If a node is created, this node is syntactically unique by definition of \texttt{Cons} and is \texttt{B}-stable (as \texttt{B} is \texttt{B}-stable)
\end{compactitem}
\end{compactitem}

By construction, the procedure \texttt{E} (generalized to accept a vector of function as input) returns a \GroBdd{} satisfying the reduction rules.

\subsubsection{Semi-Canonical}

Let $G$ be a reduced \GroBdd{}.

\paragraph{S-free and A-reduced}
For all node $v\in V$, we denote $h(v) = max(h(v.\fieldElse{}.\fieldNode{}), h(v.\fieldThen{}.\fieldNode{}))$ with $\forall t\in T, h(t) = 0$.
For all $n\in\N$, we define $V_n = \{v\in V ~|~ h(v) \leq n\}$
For all $n\in\N$, we define the recurrence hypothesis $H(n)$: \begin{compactitem}
\item For all $v\in V_n$, $\phi(v)$ is S-free.
\item For all pair of nodes $v, v'\in V_n$, $\phi(v)$ and $\phi(v')$ are A-distinct.
\end{compactitem}

\subparagraph{Initialization}
We prove $H(0)$ using the constraints that respective semantic interpretation of terminal nodes are (1) S-free and (2) A-distinct.

\subparagraph{Induction}
Let $n\in\N$, we assume $\forall k\leq n, H(k)$.
Let $v$ be a node of depth $n+1$, thus the depth of $v.\fieldElse{}.\fieldNode{}$ and $v.\fieldThen{}.\fieldNode{}$ is lower than $n$ (we can apply the recurrence hypothesis).
Therefore, the quadruple $\bar{v} = (v.\fieldElse{}.\fieldGamma{}, v.\fieldElse{}.\fieldNode{}, v.\fieldThen{}.\fieldGamma{}, v.\fieldThen{}.\fieldNode{})$ is a $\Ynode$.
Thus, using the constraints that \texttt{B} is S-free preserving, we prove that $\phi(v) = \phi(\bar{v})$ is S-free.
Let $v'$ be a node of depth $k\leq n+1$, we can prove that the quadruple $\bar{v'} = (v'.\fieldElse{}.\fieldGamma{}, v'.\fieldElse{}.\fieldNode{}, v'.\fieldThen{}.\fieldGamma{}, v'.\fieldThen{}.\fieldNode{})$ is a $\Ynode$.
Therefore, we can use the constraint that \texttt{B} is A-reduction preserving to prove that $\phi(\bar{v}) \sim_A \phi(\bar{v'}) \Rightarrow \phi(\bar{v}) = \phi(\bar{v'})$
However, $\phi(v) = \phi(\bar{v})$ and $\phi(v') = \phi(\bar{v'})$
Thus, $\forall v, w \in V_{n+1}, \phi(v) \sim_A \phi(v') \Rightarrow \phi(v) = \phi(v')$.
Hence, the respective semantic interpretations of nodes in $V_n$ are A-distinct.
Therefore $\forall n\in\N, H(n) \Rightarrow H(n+1)$.
Using the recurrence theorem, we prove that $\forall n\in\N, H(n)$.
Therefore, proving properties (2.a) and (2.b).

\paragraph{Semantic Reduction}
We prove the property "$\forall (\gamma, I, \gamma', I') \in (\Y_{n, m} \times \I_n)^2, \psi(\{\gamma = \gamma, node = I\}) = \psi(\{\gamma = \gamma', node = I'\}) \Rightarrow (\gamma, I) = (\gamma', I')$ (with $I$ and $I'$ being indexes of nodes in $G$)" by induction on $n\in\N$ the arity of $f = \psi(\{\gamma = \gamma, node = I\})$.

\subparagraph{Initialization}
The induction property holds for $n = 0$: \\
Let $f\in\F_0$, we assume there exists a quadruple $(\gamma, I, \gamma', I') \in (\Y_{n, m} \times \I_n)^2$ such that $f = \psi(\{\gamma = \gamma, node = I\}) = \psi(\{\gamma = \gamma', node = I'\})$.
However, $\Y_{0, 0} = \{Id_0\}$, therefore, $\gamma$ and $\gamma'$ are asymmetric transformation descriptors.
Hence, $\rho(a)(\phi(I)) = \rho(a')(\phi(I'))$, thus $\phi(I) \sim_A \phi(I')$.
Using the constraint, that terminals are A-reduced and canonical, we have that $\phi(I) = \phi(I')$, thus $I = I'$.

\subparagraph{Induction}
Let $k\in\N$, we assume the induction property holds for all $n\leq k$, let prove it holds for $n = k+1$.
Let $f$ be a Boolean function, we assume there exists a quadruple $(\gamma, I, \gamma', I') \in (\Y_{n, m} \times \I_n)^2$ such that $f = \psi(\{\gamma = \gamma, node = I\}) = \psi(\{\gamma = \gamma', node = I'\})$.
We decompose $\gamma$ and $\gamma'$ to their symmetric and asymmetric components: $\gamma = s \circ a$ and $\gamma' = s' \circ a'$.
Using the S-uniqueness constraint, on $f = \rho(s)(\rho(a)(\phi(I))) = \rho(s')(\rho(a')(\phi(I')))$, we have $s = s'$ and $\rho(a)(\phi(I)) = \rho(a')(\phi(I'))$.
Therefore, $\phi(I) \sim_A \phi(I')$, however, we proved that the set of the semantic interpretations of the nodes is A-reduced, thus $\phi(I) = \phi(I')$
Using the induction hypothesis (as $\phi(I)$ as an arity strictly smaller than $k+1$, thus smaller than $k$), we deduce that $I = I'$.

Therefore, applying the strong induction theorem, we prove the property (2.c).

\subsection{Model NU: proof of semi-canonicity\label{grobdd-model-nu}}

\paragraph{transformations are canonical\\}
Let $\gamma', \gamma''\in\Y_{n, m}$ be a pair of transformation descriptors, such that for all function $f\in\F_n$, $\rho(\gamma')(f) = \rho(\gamma'')(f)$.
Let $f\in\F_n$ a function with no useless variable.
We denote $S_{\gamma'} = (i'_1, \dots, i'_n)$ and $S_{\gamma''} = (i''_1, \dots, i''_n)$.
We absurdly assume that there exists an index $k$ such that $i'_k \not\in S_{\gamma''}$.
Therefore, in one hand, the $i'_k$-th variable of $\rho(\gamma')(f)$ is useless.
In the other hand, the $i'_k$-th variable of $\rho(\gamma'')(f)$ is mapped to some variable of $f$ which by definition has no useless variable, therefore, the $i_k$-th variable of $\rho(\gamma'')(f)$ is not useless.
Hence, it leads to a contradiction as $\rho(\gamma'')(f) = \rho(\gamma'')(f)$ and that useless and not useless are incompatible states.
Therefore, it does not exist such an index $k$, thus, $\gamma'.sub = \gamma''.sub$.
We absurdly assume that $\gamma'.neg \neq \gamma''.neg$, thus $\gamma'.neg = \lnot \gamma''.neg$.
Hence, it leads to a contradiction as $\rho(\gamma')(f)(\vec{0}) = \rho(\gamma'')(f)(\vec{0})$ and $\rho(\gamma')(f)(\vec{0}) = \lnot \rho(\gamma'')(f)(\vec{0})$.
Therefore, $\gamma'.neg = \gamma''.neg$.
Hence, $\gamma' = \gamma''$.

\paragraph{verified constraints on transformations}
\begin{compactitem}
\item[Separable]
Let $\gamma\in\Y_{n, m}$ be a transformation descriptor, we denote $S_{\gamma} = (i_1, \dots, i_n)$.
We define the function $\vartriangle_\gamma: \B^m \longrightarrow \B^n$ by $\forall x\in\B^m, \vartriangle_\gamma(x_1, \dots, x_m) = (x_{i_1}, \dots, x_{i_n})$.
And define the function $\triangledown_\gamma: \B^m \longrightarrow \B \longrightarrow \B$ by $\forall x\in\B^m, y\in\B, \triangledown_\gamma(x, y) = \gamma.neg \oplus y$.
Hence, $\forall \gamma\in\Y_{n, m},\forall f\in\F_n, \forall x\in\B^m, \rho(\gamma)(f)(x) = \triangledown_\gamma(x, f(\vartriangle_\gamma(x)))$.
\item[Composable]
Let $\gamma\in\Y_{n, m}$ and $\gamma'\in\Y_{m, l}$, we denote $S_{\gamma} = (i_1, \dots, i_n)$ and we denote $S_{\gamma'} = (i'_1, \dots, i'_m)$.
We define $C(\gamma, \gamma') = \gamma''$ with $\gamma'' = \{neg = \gamma.neg \oplus \gamma'.neg, sub = (i'_{i_1}, i'_{i_2}, \dots, i'_{i_n})\}$.
We can prove that $\forall f\in\F_n, \rho(\gamma')(\rho(\gamma)(f)) = \rho(C(\gamma, \gamma'))(f)$.
\item[Decomposable]
We denote $A_n = \B\times\{1\}^n \subset\Y_{n, n}$ (with $n\in\N$) and $S_{n, m} = \{0\}\times\{x\in\B^m~|~\sum_k x_k = n\}$.
We can prove that $\forall \gamma \in \Y_{n, m}, \exists a \in A_m, \exists! s \in S_{n, m}, \gamma = a \circ s$.
We can notice that, for all $n\in\N$, $\rho(A_n) = \{Id, \lnot\}$.
\end{compactitem}


\paragraph{an S-free function is A-invariant free\\}
We absurdly assume that there exists a Boolean function $f\in\F_n$ without useless variable (i.e. S-free), and a pair of distinct asymmetric transformations $a, a'\in A$ such that $\rho(a)(f) = \rho(a')(f)$.
As $A_n$ is of cardinal 2, we enumerate all cases, which lead to a contradiction as $f \neq \lnot f$.
Therefore $f$ is A-invariant free.

\subsubsection{Definition of the building algorithm \texttt{B}}
We define the building algorithm \texttt{B} as follow: 
\begin{lstlisting}
B($\gamma_0, I_0, \gamma_1, I_1$){
 if $(I_0 = I_1) \land (\gamma_0 = \gamma_1)$ then{
  $\texttt{Merge}$ $\{\gamma = \{neg = \gamma_0.neg, sub = (0, \gamma_0.sub_1, \dots, \gamma_0.sub_n)\}, node = I_0\}$
 }else{
  we define $\gamma, \gamma'_0, \gamma'_1$ by: 
   $\gamma.neg = \gamma_0$
   $\gamma'_0.neg = 0$
   $\gamma'_1.neg = \gamma_0 \oplus \gamma_1$
   $S_\gamma = \{i_1 < ... < i_{m'}\}$ = $S_{\gamma_0} \cup S_{\gamma_1}$
   $S_{\gamma'_0} = \{j_1 < ... < j_n\}$ the indexes of $S_{\gamma_0}$ in $S_{\gamma}$.
   $S_{\gamma'_1} = \{k_1 < ... < k_{n'}\}$ the indexes of $S_{\gamma_1}$ in $S_{\gamma}$.
  $\texttt{ConsNode}$ $(\gamma, (\gamma'_0, I_0), (\gamma'_1, I_1))$
 }
} 
\end{lstlisting}
The proof that \texttt{B} is correct is left to the reader.
Furthermore, we prove that $S_{\gamma'_0}\cup S_{\gamma'_1} = \{1, \dots, m'\}$.

\paragraph{\texttt{B} is \texttt{B}-stable}
We have to prove that
\[\mathtt{B}(\gamma_0, I_0, \gamma_1, I_1) \in \Y_{n, m}) = \mathtt{ConsNode}(\gamma, (\gamma'_0, I'_0), (\gamma'_1, I'_1))\] \[\Rightarrow \mathtt{B}(\gamma'_0, I'_0, \gamma'_1, I'_1) = \mathtt{ConsNode}(Id, (\gamma'_0, I'_0), (\gamma'_1, I'_1))\]
We absurdly assume that $\mathtt{B}(\gamma'_0, I'_0, \gamma'_1, I'_1) \neq \mathtt{ConsNode}(Id, (\gamma'_0, I'_0), (\gamma'_1, I'_1))$: \begin{compactitem}
\item We absurdly assume that $\mathtt{B}(\gamma'_0, I'_0, \gamma'_1, I'_1) = \mathtt{Merge}(\gamma, I)$.
Therefore, by definition of \texttt{B}, $\gamma'_0 = \gamma'_1$ and $I'_0 = I'_1$, thus $\gamma_0 = \gamma_1$ and $I_0 = I_1$, hence it leads to a contradiction as $\mathtt{B}(\gamma_0, I_0, \gamma_1, I_1) \in \Y_{n, m}) = \mathtt{Merge} \dots$.
\item Therefore, $\mathtt{B}(\gamma'_0, I'_0, \gamma'_1, I'_1) = \mathtt{ConsNode}(\gamma', (\gamma''_0, I''_0), (\gamma''_1, I''_1))$: \begin{compactitem}
\item We absurdly assume that $\gamma' \neq Id$.
However, $\gamma'.neg = \gamma'_0.neg = 0$ (by definition of \texttt{B}, therefore $\gamma'.sub \neq (1, \dots, 1) \in\B^n$.
Thus, there exists $i$ such that $\gamma'.sub_i = 0$, thus, there exists an index $k'$ such that $k'\not\in S_{\gamma'_0}\cup S_{\gamma'_1}$, which leads to a contradiction as $S_{\gamma'_0}\cup S_{\gamma'_1} = \{1, \dots, m'\}$.
\item Therefore, $\gamma' = Id$.
Thus, $\gamma''_0 = \gamma'_0$, $\gamma''_1 = \gamma'_1$, $I''_0 = I'_0$ and $I''_1 = I'_1$.
Hence it leads to a contradiction as we assumed that $\mathtt{B}(\gamma'_0, I'_0, \gamma'_1, I'_1) \neq \mathtt{ConsNode}(Id, (\gamma'_0, I'_0), (\gamma'_1, I'_1))$.
\end{compactitem}
\end{compactitem}

Therefore, \texttt{B} is \texttt{B}-stable.

\paragraph{\texttt{B} is S-free preserving\\}
Let $v=(\gamma_0, I_0, \gamma_1, i_1)$ be a $\Ynode$, therefore, the Boolean functions $\phi(I_0)$ and $\phi(I_1)$ are S-free and $\phi(I_0) \sim_A \phi(I_1) \Rightarrow I_0 = I_1$
We absurdly assume that the Boolean function $\phi(v) = \rho(\gamma_0)(\phi(I_0)) \star \rho(\gamma_1)(\phi(I_1))$ is not S-free, thus, there exists an index $k$ such that the $k$-th variable of $\phi(v)$ is useless.
\begin{compactitem}
\item If $k=0$, then, $\rho(\gamma_0)(\phi(I_0)) = \rho(\gamma_1)(\phi(I_1))$.
Using the S-uniqueness constraint ($\phi(I_0)$ and $\phi(I_1)$ being S-free), we prove that $\phi(I_0) \sim_A \phi(I_1$, thus $I_0 = I_1$.
Hence, leading to a contradiction as the $\Ynode$ $v$ is assumed to be \texttt{B}-stable.
\item If $k>0$, then, the $(k-1)$-th variables of the Boolean functions $\rho(\gamma_0)(\phi(I_0))$ and $\rho(\gamma_1)(\phi(I_0))$ are useless.
Using the S-uniqueness constraint ($\phi(I_0)$ and $\phi(I_1)$ being S-free), we prove that $\gamma_0.sub_{k-1} = \gamma_1.sub_{k-1} = 0$.
Hence, leading to a contradiction as the $\Ynode$ $v$ is assumed to be \texttt{B}-stable.
\end{compactitem}

\paragraph{\texttt{B} is A-reduction preserving\\}
Let $v=(\gamma_0, I_0, \gamma_1, I_1)$ and $v'=(\gamma'_0, I'_0, \gamma'_1, I'_1)$ be $\Ynodes$, such that $\phi(v) \sim_A \phi(v')$.
Thus, there exists an asymmetric transformation descriptor $a$ such that $\phi(v) = \rho(a)(\phi(v'))$
Therefore, the Boolean functions $\phi(I_0), \phi(I_1), \phi(I'_0)$ and $\phi(I'_1)$ are S-free and the set of Boolean functions $\{\phi(I_0), \phi(I_1), \phi(I'_0), \phi(I'_1)\}$ is A-reduced.
Thus, using the expansion theorem, $\rho(\gamma_0)(\phi(I_0)) = \rho(a \circ \gamma'_0)(\phi(I'_0))$ and $\rho(\gamma_1)(\phi(I_1)) = \rho(a \circ \gamma'_1)(\phi(I'_1))$.
Using the S-uniqueness constraint, we prove that $\phi(I_0) \sim_A \phi(I'_0)$ and $\phi(I_1) \sim_A \phi(I'_1)$ (and $\gamma_0 = a \circ \gamma'_0$ and $\gamma_1 = a \circ \gamma'_1$), thus, using the A-reduction property, $I_0 = I'_0$ and $I_1 = I'_1$.

Therefore, $v'=(\gamma'_0, I_0, \gamma'_1, I_1)$.
We proved that $\gamma_0 = a \circ \gamma'_0$, however, $v$ and $v'$ and \texttt{B}-stable, thus $\gamma_0.neg = \gamma'_0.neg = 0$, thus $a = Id$.
Hence, $\gamma_1 = \gamma'_1$.
We proved that $v = v'$.

\end{document}
